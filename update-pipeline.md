# ChatterFox Auto-Update Pipeline

## Overview

ChatterFox inherits Handy's auto-update system (`tauri-plugin-updater`), but the endpoint
and signing key currently point at the upstream `cjpais/Handy` repo. Until fixed:

- Users will receive **Handy** updates, not ChatterFox updates
- Newly signed ChatterFox builds will **fail signature verification** on the client

This document tracks everything needed to take full ownership of the update pipeline.

**Status:** ðŸ”² Not started

---

## How It Works (Background)

1. On update check, the app fetches `latest.json` from the configured endpoint URL
2. `latest.json` is auto-generated by the `tauri-apps/tauri-action` GitHub Action and uploaded to the release
3. The JSON contains version info + download URLs + per-file signatures
4. The app verifies each download's signature against the **pubkey** baked into `tauri.conf.json`
5. You need your own **minisign keypair** â€” private key signs releases (lives in GitHub Secrets), public key lives in `tauri.conf.json`

---

## Current Broken State (verified 2026-02-18)

| Location | Current (wrong) value |
|---|---|
| `src-tauri/tauri.conf.json` â†’ `plugins.updater.endpoints` | `https://github.com/cjpais/Handy/releases/latest/download/latest.json` |
| `src-tauri/tauri.conf.json` â†’ `plugins.updater.pubkey` | Handy's public key (`dW50cnVzdGVkIGNvbW1lbnQ6â€¦`) |
| `.github/workflows/release.yml` â†’ `asset-prefix` | `"handy"` (release asset filenames will be `handy_*`) |
| `src-tauri/tauri.conf.json` â†’ `bundle.windows.signCommand` | References `CJ-Signing` / `cjpais-dev` Azure account |

---

## Files to Modify

| File | Change |
|---|---|
| `src-tauri/tauri.conf.json` | Update `plugins.updater.endpoints` + replace `plugins.updater.pubkey` |
| `src-tauri/tauri.conf.json` | Update `bundle.windows.signCommand` to ChatterFox Azure signing identity (or remove if not using Azure) |
| `.github/workflows/release.yml` | Change `asset-prefix: "handy"` â†’ `asset-prefix: "chatterfox"` |

---

## Step-by-Step Tasks

### Step 1 â€” Generate a New Minisign Keypair

Run once on your local machine. Never commit the private key.

```bash
# Install minisign if needed
brew install minisign          # macOS
# or: cargo install minisign

# Generate keypair
minisign -G -p ~/.tauri/chatterfox.pub -s ~/.tauri/chatterfox.key
# Enter a passphrase when prompted (save it â€” you'll need it for GitHub Secrets)
```

- **Private key** â†’ `~/.tauri/chatterfox.key` â€” never commit this
- **Public key** â†’ printed to terminal and saved to `~/.tauri/chatterfox.pub`
  - Looks like: `dW50cnVzdGVkIGNvâ€¦` (base64 string)
  - Save this â€” it goes into `tauri.conf.json`

To retrieve the public key string later:
```bash
cat ~/.tauri/chatterfox.pub
```

- [ ] Keypair generated
- [ ] Public key string saved somewhere safe for Step 3

---

### Step 2 â€” Add Secrets to GitHub Repository

In **jayintheday/chatterfox** â†’ Settings â†’ Secrets and variables â†’ Actions:

| Secret Name | Value |
|---|---|
| `TAURI_SIGNING_PRIVATE_KEY` | Full contents of `~/.tauri/chatterfox.key` |
| `TAURI_SIGNING_PRIVATE_KEY_PASSWORD` | Passphrase entered during key generation |

The `build.yml` workflow already reads these secret names at lines 280â€“281 â€” no workflow
changes needed for the Tauri signing step.

> **macOS note:** Apple code signing requires additional secrets already referenced in
> `build.yml` (`APPLE_CERTIFICATE`, `APPLE_CERTIFICATE_PASSWORD`, `KEYCHAIN_PASSWORD`,
> `APPLE_ID`, `APPLE_PASSWORD`, `APPLE_TEAM_ID`). These are separate from the Tauri
> updater key and must be supplied if distributing signed macOS builds.

> **Windows note:** The current `signCommand` references the upstream `CJ-Signing` / `cjpais-dev`
> Azure Trusted Signing account. See Step 3b to address this.

- [ ] `TAURI_SIGNING_PRIVATE_KEY` added to repo secrets
- [ ] `TAURI_SIGNING_PRIVATE_KEY_PASSWORD` added to repo secrets

---

### Step 3a â€” Update `tauri.conf.json` (updater block)

File: `src-tauri/tauri.conf.json`

Replace the `plugins.updater` block:

```json
"plugins": {
  "updater": {
    "pubkey": "<YOUR_NEW_PUBLIC_KEY_HERE>",
    "endpoints": [
      "https://github.com/jayintheday/chatterfox/releases/latest/download/latest.json"
    ]
  }
}
```

Replace `<YOUR_NEW_PUBLIC_KEY_HERE>` with the public key output from Step 1.

- [ ] `endpoints` updated to `jayintheday/chatterfox`
- [ ] `pubkey` replaced with new ChatterFox public key

---

### Step 3b â€” Update `tauri.conf.json` (Windows sign command)

File: `src-tauri/tauri.conf.json`

The current Windows sign command references the upstream Azure account:

```json
"signCommand": "trusted-signing-cli -e https://eus.codesigning.azure.net/ -a CJ-Signing -c cjpais-dev -d ChatterFox %1"
```

**Options:**
- If you have your own Azure Trusted Signing account: update `-a` (account name) and `-c`
  (certificate profile) to your own values, and add `AZURE_CLIENT_ID`,
  `AZURE_CLIENT_SECRET`, `AZURE_TENANT_ID` to GitHub Secrets
- If you are not code-signing Windows builds yet: remove the `signCommand` line entirely
  (unsigned builds still work, users just see a SmartScreen warning on first run)

- [ ] Windows `signCommand` updated or removed

---

### Step 4 â€” Fix Asset Prefix in `release.yml`

File: `.github/workflows/release.yml`

Change line 77:

```yaml
# Before
asset-prefix: "handy"

# After
asset-prefix: "chatterfox"
```

This controls the filename prefix on release artifacts (`.dmg`, `.exe`, `.deb`, etc.) and
must match for `latest.json` URLs to resolve correctly.

- [ ] `asset-prefix` updated to `"chatterfox"`

---

### Step 5 â€” Trigger the First Release

1. Commit all `tauri.conf.json` and `release.yml` changes to `main`
2. Go to **Actions â†’ Release â†’ Run workflow** in the GitHub UI
   (the workflow triggers on `workflow_dispatch`, not on push/tag)
3. The workflow will:
   - Create a draft GitHub Release named `vX.Y.Z` (version from `tauri.conf.json`)
   - Build platform-specific binaries across all matrix runners
   - Sign each artifact with `TAURI_SIGNING_PRIVATE_KEY`
   - Generate `latest.json` with correct URLs and signatures
   - Upload all artifacts to the draft release
4. Review the draft release, then publish it

- [ ] Release workflow run successfully
- [ ] `latest.json` present in GitHub Release assets
- [ ] All platform artifacts uploaded and named `chatterfox_*`

---

### Step 6 â€” Verify End-to-End

1. Install an older build of ChatterFox locally
2. Trigger "Check for Updates" from the tray menu
3. The app should fetch `https://github.com/jayintheday/chatterfox/releases/latest/download/latest.json`
4. If a newer version exists, it should offer to install it
5. After download, the signature check should pass (install completes without error)

- [ ] Update check fetches from `jayintheday/chatterfox`
- [ ] Newer version detected and offered
- [ ] Signature verification passes (no error on install)
- [ ] App relaunches to updated version

---

## Verification Checklist (summary)

- [ ] `tauri.conf.json` endpoint points to `jayintheday/chatterfox` (not `cjpais/Handy`)
- [ ] `tauri.conf.json` pubkey is the new ChatterFox public key (not Handy's key)
- [ ] `tauri.conf.json` Windows `signCommand` updated or removed
- [ ] `release.yml` `asset-prefix` is `"chatterfox"` (not `"handy"`)
- [ ] GitHub Secrets `TAURI_SIGNING_PRIVATE_KEY` and `TAURI_SIGNING_PRIVATE_KEY_PASSWORD` are set
- [ ] Release workflow completes successfully and uploads `latest.json`
- [ ] Installed app checks for updates against the new endpoint
- [ ] Update installs and relaunches correctly

---

## Notes

- The `pubkey` in `tauri.conf.json` is the verifier â€” it is safe to commit publicly
- The private key must **never** be committed; store it only in `~/.tauri/` and GitHub Secrets
- The endpoint URL can be any HTTPS URL serving valid `latest.json` â€” GitHub Releases is
  the convention used here
- `latest.json` does **not** need to be written or uploaded manually â€” `tauri-apps/tauri-action` handles it
- For staged rollouts in future, the endpoint can point to your own API that returns the
  same JSON format with a subset of users targeted
